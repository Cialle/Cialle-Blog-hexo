---
title: Java学习之 基本数据类型及IEEE754
author: Cialle
categories:
  - Java学习
tags:
  - java学习
  - 数据类型
  - IEEE754
date: 2022-06-10 17:24:00
math: true
---

# 概述



**本章主要讨论Java 数据类型。讲解原码、反码、补码之间的区别，以及IEEE 754标准。**



# 内置数据类型



Java提供了八种基本数据类型。其中包括：六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。

| 数据类型 | 表示类型 |  占用   | 默认值 | 最小值 | 最大值 |
| :------: | :-----: | :----: | :----: | :----: | :----: |
|   [**byte**](#byte)   |   有符号   | **8bit** | **0** |   -128**（-2<sup>7)</sup>）**   | 127**（2<sup>7</sup>-1）** |
| [**short**](#short) | 有符号 |  **16bit**  | **0** |   -32768**（-2<sup>15</sup>）**   | 32767**（2<sup>15</sup>-1）** |
| [**int**](#int) | 有符号 |  **32bit**  | **0** |   -2,147,483,648**（-2<sup>31</sup>）**   | 2,147,483,647**（2<sup>31</sup>-1）** |
|   [**long**](#long)   |   有符号   |  **64bit**  | **0L** |   -9,223,372,036,854,775,808**（-2<sup>63</sup>）**   | 9,223,372,036,854,775,807**（2<sup>63</sup>-1）** |
| [**float**](#float) | 单精度 |  **32bit**  | **0.0f** | [IEEE754](#IEEE二进制浮点数算术标准（IEEE 754）) | [IEEE754](#IEEE二进制浮点数算术标准（IEEE 754）) |
|  [**double**](#double)  |  双精度  |  **64bit**  | **0.0d** | [IEEE754](#IEEE二进制浮点数算术标准（IEEE 754）) | [IEEE754](#IEEE二进制浮点数算术标准（IEEE 754）) |
|   [**char**](#char)   |   无符号   |  **16bit**  | **\u0000** | Unicode 0**（\u0000）** | Unicode 65535 (2<sup>16</sup>-1)**（\uffff）** |
| [**boolean**](#boolean) | 仅两个有效值 | **8/32bit** | **false** | **false** | **true** |

## 基本数据类型代码举例

#### **byte**

```java
// 命名方法，由于没有 byte字面量 ，故可以将任何落在 字节范围 内的 int字面量 分配给一个字节变量
byte b1 = 125;
byte b2 = -11;

//一些相关常量
byte max = Byte.MAX_VALUE; //最大值
byte min = Byte.MIN_VALUE; //最小值
```



#### **short**

```java
// 命名方法，由于没有 short字面量 ，故可以将任何位于 short范围 内的 int字面量 分配给一个短变量。
short s1  = 11111;
short s2  = -11111;

//一些相关常量
short max = Short.MAX_VALUE; //最大值
short min = Short.MIN_VALUE; //最小值
```



#### **int**

```java
// 命名方法 一个整数字面量 可以分配给一个 int变量
int num1 = 21;				// 值没有前导零，它是十进制数字格式。
int num2 = 021;			// 当整数字面量以 零开始  开头并且至少有 两个八进制数字，  它被认为是 八进制数 格式。
int num3 = 0x1A2B;			// 当整数字面量以 0x或0X 开头并且至少有 一个十六进制数字, 它被认为是 十六进制数 格式。
int num4 = 0b10101;		// 当整数字面量以 0b或0B 开头并且至少有 一个二制数字,    它被认为是 十六进制数 格式。

//一些相关常量
int max = Integer.MAX_VALUE; //最大值
int min = Integer.MIN_VALUE; //最小值
```



#### **long**

```java
// 命名方法 long的范围内的所有整数称为long类型的整数字面量。 long类型的整数常数总是以L或小写l结尾。推荐使用大写L来表示，容易和数字1混淆
long num1 = 25L;       // 长整型字面量 十进制   格式
long num2 = 031L;      // 长整型字面量 八进制   格式
long num3 = 0X19L;     // 长整型字面量 十六进制 格式
long num4 = 0b11001L;  // 长整型字面量 二进制   格式

//一些相关常量
long max = Long.MAX_VALUE; //最大值
long min = Long.MIN_VALUE; //最小值
```



#### **float**

```java
// 它是不精准的，可见后续章节 《小数类型的二进制表示方式》

// 命名方法 所有以f或F结尾的实数称为浮点字面量。浮点文本可以用以下两种格式表示：
float f1 = 1F;			// 十进制数字 浮点字面量 格式
float f2 = 2.f; 
float f3 = 3.0F; 
float f4 = 4.51f; 

float f5 = 42.5E-1F;	// 科学计数法 浮点字面量 格式
float f6 = 0.425E+1f;
float f7 = 0.425e1F;
    

//一些相关常量
float positive_infinity = Float.POSITIVE_INFINITY; // 正数无穷大 例如：1.0f / 0.0f; 特例说明：正数无穷大加上一个数还是正数无穷大。
float negative_infinity = Float.NEGATIVE_INFINITY; // 负数无穷大 例如：-1.0f / 0.0f 特例说明：同理整数无穷大
float nan = Float.NaN;	/* 
							not a number 对于所有没有良好的数字定义的浮点计算，
							例如：
								0.0f / 0.0f 
								Float.POSITIVE_INFINITY + Float.NEGATIVE_INFINITY
							特例说明：
								即它与任何数比较均返回false，但是使用Float.compare()比较两个NaN时，会得到true
								任何浮点操作，只要它的一个或多个操作数为NaN，那么其结果为NaN。 
						*/
float MAX_VALUE  = Float.NEGATIVE_INFINITY;			// 最大值
float MIN_VALUE  = Float.NEGATIVE_INFINITY;			// 最小值
```



#### **double**

```java
// 它是不精准的，可见后续章节 《小数类型的二进制表示方式》

// 命名方法 所有实数被称为双精度字面量。双精度字面量可以可选地以d或D结尾。后缀d或D在双精度字面量中是可选的。
double d1 = 8D ;			// 十进制数字 双精度字面量 格式
double d2 = 8.; 
double d3 = 8.d; 
double d4 = 78.9867D; 

double d5 = 42.5E-1d;		// 科学计数法 双精度字面量 格式
double d6 = 0.425E+1D;
double d7 = 0.425e1;
    

//一些相关常量
double positive_infinity = Double.POSITIVE_INFINITY // 正数无穷大 例如：1.0f / 0.0f; 特例说明：正数无穷大加上一个数还是正数无穷大。
double negative_infinity = Double.NEGATIVE_INFINITY // 负数无穷大 例如：-1.0f / 0.0f 特例说明：同理整数无穷大
double nan = Double.NaN;	/* 
								not a number 对于所有没有良好的数字定义的浮点计算，
								例如：
									0.0f / 0.0f 
									Double.POSITIVE_INFINITY + Double.NEGATIVE_INFINITY
								特例说明：
									即它与任何数比较均返回false，但是使用Double.compare()比较两个NaN时，会得到true
									任何浮点操作，只要它的一个或多个操作数为NaN，那么其结果为NaN。 
							*/
double MAX_VALUE  = Double.MAX_VALUE;				// 最大值
double MIN_VALUE  = Double.MIN_VALUE;				// 最小值
```





#### **char**

```java
//命名方法 字符字面量表示char数据类型的值。
char c1  = 'A';			// 用单引号括起来的 一个字符
char c2  = '中';			// 用单引号括起来的 一个中文字符
char c3  = 65;				// 整型字面量格式 char变量表示其Unicode代码等于该字符串表示的值的字符。
char c4  = '\u0041';		// 用单引号括起来的 Unicode转义序列 \u表示Unicode转义序列的开始，xxxx正好表示四个十六进制数字。
char c5  = '\101';			// 用单引号括起来的 八进制转义序列 范围为 \000 - \377
char c6  = '\n';			/* 用单引号括起来的 字符转义序列 Java中只有八个。不能自己定义，分别是：
								'\n'换行 
								'\r'回车 
								'\f'表单Feed 
								'\b'退格 
								'\t'指表 
								'\\'反斜杠 
								'\"'双引号 
								'\''单引号
							*/

//一些相关常量
char max = Character.MAX_VALUE; //最大值
char min = Character.MIN_VALUE; //最小值
```



#### **boolean**

```java
//命名方法 布尔变量不能转换为任何其他数据类型，反之亦然。
boolean b1 = true;			//布尔值字面量 真
boolean b2 = false;		//布尔值字面量 假
```


# 详解

## 整数类型的二进制表示方式

​	要理解整数的二进制，我们先看看我们熟悉的十进制。比如**637**，我们可以不假思索的想到他的值是多少。

​	但事实是 **637** 表示的是 **6×10<sup>2</sup> + 3×10<sup>1</sup> + 7×10<sup>0</sup>** ，它表示的是各个位置数字含义之和。

​	换句话说，每个位置都有一个位权：
​	<font color=red>从右到左，第一位为10<sup>0</sup>，然后指数依次加一，即第二位为10<sup>1</sup>，第三位为10<sup>2</sup>，依次类推。</font>

### 正整数的二进制表示

​	同理，只是在十进制之中，每个位置是可以有0-9一共10个数字。但在二进制之中，每个位置只能是0或1，但位权的概念是一样的：
​	<font color=red>从右到左，第一位为2<sup>0</sup>，然后指数依次加一，即第二位为2<sup>1</sup>，第三位为2<sup>2</sup>，依次类推。</font>

来看些例子吧~

![image-20220611012626608](https://img.cialle.com/202206110126755.png)

### 十进制正整数转换二进制

​	<font color=red>十进制整数转换为二进制整数采用"除2取余，逆序排列"法。</font>

​	具体做法是：用2整除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为小于1时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。

​	**以36（0010 0100）为例**

```
36 ÷ 2 = 18 余 0
18 ÷ 2 = 9 余 0
9 ÷ 2 = 4 余 1
4 ÷ 2 = 2 余 0
2 ÷ 2 = 1 余 0
1 ÷ 2 = 0 余 1
则将余数结果顺序排列为：001001
反向排列为：100100
```

​	**再举个例子：200（11001000）**

```
200 ÷ 2 = 100 余 0
100 ÷ 2 = 40 余 0
50 ÷ 2 = 25 余 0
25 ÷ 2 = 12 余 1
12 ÷ 2 = 6 余 0
6 ÷ 2 = 3 余 0
3 ÷ 2 = 1 余 1
1 ÷ 2 = 0 余 1
则将余数结果顺序排列为：00010011
反向排列为：11001000
```



### 计算机中的二进制数表现形式

​	计算机中的二进制数分为两种：无正负的类型称为**无符号数** 和 可以区分正负的类型称为**有符号数**

#### 无符号数（unsigned）

- 直接用二进制表示。
- 寄存器的位数反映了无符号数的表示范围。
- 对于无符号数，二进制比较容易理解，只有 **char** 它的表示范围为16个bit则为：

```
0000 0000 0000 0000			0
0000 0000 0000 0001			1
0000 0000 0000 0010			2
...                			...
1111 1111 1111 1111			65535
```

​	那么通过上述可知**char**的最大值为65535

#### 有符号数（signed）

​	有符号数整数，又分成两部分：符号位 与 数值位

​	符号位：指 最高位，0代表正数，1代表负数。
​		<sub>注：这里有个扯淡的问题，为什么0是正数，1是负数。看到一个博主写到：当代绝大多数计算机表示浮点型均为采用IEEE标准，则其实使用(-1)<sup>s</sup>×X 来表示，当s为0时，则该式即为正式，而s为1时，则反之。蛮有趣记录下来</sub>

​	数值位则 指 剩下的所有位。

举个例子。

![image-20220606214218804](https://img.cialle.com/202206062142900.png)

### 负整数的二进制表示

> 注：以下内容有些深入，但你真正看懂上述文章后，去尝试理解下面的内容，你会发现很有意思。让我们开始吧~

**在计算机中，负数以其正值的补码形式表达。**

要理解负整数在计算机中的表示方式。我们先要学习**机器数**、**真值**、**原码**、**反码**、**补码**。

#### 机器数和真值

> 建议深入理解这两个概念。否则后续会吃力

##### 机器数

- 一个数在计算机中的表现形式，叫做这个数的**机器数**
- 常用的**机器数**有：**原码**、**反码** 和 **补码**
- 它有两个特点：一是数字符号化，二是其数的大小机器字长的限制
- 举个例子：十进制的+6、计算机字长是8位、机器码为原码，转换二进制就是`0000 0110`，而-6则为`1000 0110`
- 那么这里的`0000 0110`和`1000 0110` 就是**机器数**

#### 真值

- 带符号位的机器数对应的数值称为机器数的**真值**。 
- 例如原码二进制机器数 `1000 0111`，它的真值数为 `-000 0111`即为`-6`。

#### 原码、反码 和 补码

> 对于一个数, 计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的编码方式.

##### 原码

1. 一句话表述：
	- <font color=red>第一位符号位，后面放真值的数值位</font>
   
2. 计算方法：	
   - 符号位用0表示正，用1表示负
   - 数值位不变，即为真值的绝对值。
   
3. 表示方式：
   - +6 = [0000 0110]<sub>原</sub>
   - -6 = [1000 0110]<sub>原</sub>
   
4. 优点：
   - 计算方便，原码是人脑最容易理解和计算的表示方式
   
5. 缺点：
   - 运算不方便，无法直接进行减法
   - `真值0` 有 `+0 [0000 0000]` 和 `-0 [1000 0000]` 两种不同的表示方法


##### 反码

1. 一句话表述：
	- <font color=red>正数不变，负数用原码按位取反</font>
   
2. 计算方法：
	- 符号位用0表示正，用1表示负
	- 数值位与符号位相关
	- 正数时，数值位不变，即为真值的绝对值。
	- 负数时，数值位是**真值**的**数值位**按位取反（0变为1，1变为0）。
   


3. 表示方式：
   - +6 = [0000 0110]<sub>原</sub> = [0000 0110]<sub>反</sub> 
   - -6 = [1000 0110]<sub>原</sub> = [1111 1001]<sub>反</sub> 
   


4. 优点：
   - 运算方便，可以将减法运算转化为加法运算
   
5. 缺点：
   - 计算不方便，人脑无法以直观的形式计算，需要用原码取反
   - `真值0` 有 `+0 [0000 0000]` 和 `-0 [1000 0000]` 两种不同的表示方法


##### 补码

1. 一句话表述：
	- <font color=red>正数不变，负数用反码加1</font>
   
2. 计算方法：
	- 符号位用0表示正，用1表示负
	- 数值位与符号位相关
	- 正数时，数值位不变，即为真值的绝对值。
	- 负数时，数值位是**真值**的**数值位**按位取反（0变为1，1变为0），并在末位加1。
   
3. 表示方式：
   - +6 = [0000 0110]<sub>原</sub> = [0000 0110]<sub>反</sub> = [0000 0110]<sub>补</sub> 
   - -6 = [1000 0110]<sub>原</sub> = [1111 1001]<sub>反</sub> = [1111 1010]<sub>补</sub> 
   
4. 优点：
   - 运算方便，可以将减法运算转化为加法运算
   - `真值0` 仅有 `+0 [0000 0000]` 一种表示方法
   
5. 缺点：
   - 计算不方便，人脑无法以直观的形式计算，需要用原码取反再加1



##### 三种机器数对比

![image-20220608225118119](https://img.cialle.com/202206082251271.png)

##### 例子

> 为了更好的让你理解，尝试用此章节上述内容做个练习题吧 

```yaml
//下列内容以8bit举例

+32  =  [         ]原  =  [         ]反  =  [         ]补 
-12  =  [         ]原  =  [         ]反  =  [         ]补 
+7   =  [         ]原  =  [         ]反  =  [         ]补 
-124 =  [         ]原  =  [         ]反  =  [         ]补
```




> 尝试进阶一下呢

```yaml
//下列内容以int型举例

+3661 =  [                                          ]原  
	  =  [                                          ]反  
	  =  [                                          ]补 

-1269 =  [                                          ]原  
	  =  [                                          ]反  
	  =  [                                          ]补 
```



##### 答案

> 来看看你做的对不对吧
``` yaml
//下列内容以8bit举例

+32  =  [0010 0000]原  =  [0010 0000]反  =  [0010 0000]补 
-12  =  [1000 1100]原  =  [1111 0011]反  =  [1111 0100]补 
+7   =  [0000 0111]原  =  [0000 0111]反  =  [0000 0111]补 
-124 =  [1111 1100]原  =  [1000 0011]反  =  [1000 0100]补 
```


> 光byte会了可没用哦
```yaml
//下列内容以int型举例

+3661 =  [0000 0000  0000 0000  0000 1110  0100 1101]原  
	  =  [0000 0000  0000 0000  0000 1110  0100 1101]反  
	  =  [0000 0000  0000 0000  0000 1110  0100 1101]补 

-1269 =  [1000 0000  0000 0000  0000 0100  1111 0101]原  
	  =  [1111 1111  1111 1111  1111 1011  0000 1010]反  
	  =  [1111 1111  1111 1111  1111 1011  0000 1011]补 
```


#### 为什么要使用这三个码

> 在深入了解之前，我的建议是先把题做的真正理解。

由上可见：原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?

我们知道, 根据运算法则减去一个正数等于加上一个负数
​即: `6-6 = 6 + (-6) = 0`

来看 **计算十进制表达式：**`6 - 6 = 0` 的**原码**计算：

```yaml
6 - 6 = 6 + (-6) 
	  = [0000 0110]原 + [1000 0110]原 
	  = [1000 1100]原 
	  = -12
```

显然对于减法来说，结果是不正确的，这也就是为何计算机内部不能使用原码表示一个数
​所以，为了解决原码做减法的问题，出现了反码

同样来看 **计算十进制表达式：**`6 - 6 = 0` 的**反码**计算：

```yaml
6 - 6 = 6 + (-6) 
	  = [0000 0110]原 + [1000 0110]原 
	  = [0000 0110]反 + [1111 1001]反
	  = [1111 1111]反
	  = [0000 0000]原
	  = 0
```

我们发现，用反码计算减法，结果的真值部分是正确的
​但唯一的问题，就出现在 0 这个特殊的数值上
​虽然在人们的理解上，+0 和 -0 是一样的，但0带符号是没有任何意义的
​而且会有 `[0000 0000] 和 `[1000 0000]` 两种不同的表示方法

于是补码的出现，解决了这些问题
​来看 **计算十进制表达式：**`6 - 6 = 0` 的**补码**计算：

```yaml
6 - 6 = 6 + (-6) 
	  = [0000 0110]原 + [1000 0110]原 
	  = [0000 0110]补 + [1111 1010]补 
	  = [0000 0000]补 
	  = [0000 0000]原
	  = 0
```

这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用`[1000 0000]`表示-128:

```yaml
-1 + (-127) 
	  = [1000 0001]原 + [1111 1111]原 
	  = [1111 1111]补 + [1000 0001]补 
	  = [1000 0000]补 
	  = -128
```

注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.



## 小数类型的二进制表示方式

先来看一段简单的代码

```java
public static void main(String[] args) {
    System.out.println(1.0f - 0.9f);
    System.out.println(0.1 + 0.2);
}
```

打印结果如下：

```java
0.100000024				// 1.0f - 0.9f
0.30000000000000004		// 0.1 + 0.2
```

**为什么会出现这种诡异的答案呢？**

### IEEE二进制浮点数算术标准（IEEE 754）

> **[IEEE](https://zh-m-wikipedia-org.translate.goog/wiki/电气电子工程师协会?_x_tr_sl=zh-TW&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=sc)二进制浮点数算术标准**（ **IEEE 754**）是20世纪80年代以来最广泛使用的[浮点数](https://zh-m-wikipedia-org.translate.goog/wiki/浮點數?_x_tr_sl=zh-TW&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=sc)运算标准，为许多[CPU](https://zh-m-wikipedia-org.translate.goog/wiki/中央處理單元?_x_tr_sl=zh-TW&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=sc)与[浮点运算器](https://zh-m-wikipedia-org.translate.goog/wiki/浮点运算器?_x_tr_sl=zh-TW&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=sc)所采用。这个标准定义了表示浮点数的格式（包括负零[-0](https://zh-m-wikipedia-org.translate.goog/wiki/-0?_x_tr_sl=zh-TW&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=sc)）与反常值（denormal number），一些特殊数值（（[无穷](https://zh-m-wikipedia-org.translate.goog/wiki/無窮?_x_tr_sl=zh-TW&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=sc)（Inf）与[非数值](https://zh-m-wikipedia-org.translate.goog/wiki/NaN?_x_tr_sl=zh-TW&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=sc)（NaN）），以及这些数值的“浮点数运算符”；它也指明了四种[数值舍入规则](https://zh-m-wikipedia-org.translate.goog/wiki/數值修約規則?_x_tr_sl=zh-TW&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=sc)和五种例外状况（包括例外发生的时机与处理方式）。
>
> IEEE 754规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43位元以上，很少使用）与延伸双精确度（79位元以上，通常以80位实现）。只有32位模式有强制要求，其他都是选择性的。大部分[编程语言](https://zh-m-wikipedia-org.translate.goog/wiki/程式語言?_x_tr_sl=zh-TW&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=sc)都提供了IEEE浮点数格式与算术，但有些将其列为非必需的。例如，IEEE 754问世之前就有的[C语言](https://zh-m-wikipedia-org.translate.goog/wiki/C語言?_x_tr_sl=zh-TW&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=sc)，现在包括了IEEE算术，但不算作强制要求（C语言的`float`通常是指IEEE单精确度，而`double`是指双精确度）。
>
> 该标准的全称为**IEEE二进制浮点数算术标准（ANSI/IEEE Std 754-1985）**，又称**IEC 60559:1989，微处理器系统的二进制浮点数算术**（本来的编号是IEC 559:1989）[[1\]](https://zh-m-wikipedia-org.translate.goog/zh-my/IEEE_754?_x_tr_sl=zh-TW&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=sc#cite_note-1)。后来还有“与基数无关的浮点数”的“IEEE 854-1987标准”，有规定基数为2跟10的状况。现在最新标准是“ISO/IEC/IEEE FDIS 60559:2020”。

> 简单来讲，王八的屁股，龟腚。^^，上面的大概看下、了解下即可。

#### 理论部分

> **这部分主要了解理论部分，后面会有举例部分，建议可以结合来看。当然直接跳过理论也可以。**

##### 小数转二进制

分成两部分：整数，小数。（注：这里均以真值表示）



整数部分：

很简单，均直接十进制转二进制即可：[**除2取余，逆序排列**](#十进制正整数转换二进制)
6  = +0110
-6 = -0110



小数部分：

也不难，一个小概念 - **乘2取整，正序排列**：
具体做法：将**小数**部分×2，将得到的结果**整数**部分留下，再次将**小数**部分×2，将得到的结果**整数**部分留下，一直重复。直到**小数**部分结果为**0**。最后将整数部分正序排列。
例如：[0.625]<sub>10</sub> = [0.101]<sub>2</sub>
0.625 * 2 = 1.25————取出整数部分 1 ，剩余 0.25
0.25  * 2 = 0.5—————取出整数部分 0 ，剩余 0.5
0.5   * 2 = 1.0—————取出整数部分 1 ，剩余 0



综上所述，可以简单将

-60.125 变为 -111100.001



##### 温习科学计数法

$$
十进制的科学计数法 \\
a × 10^b = aEb  \\
60.125 = 6.0125 × 10^{-1} = 6.0125E{-1}\\
\\
二进制\\
-60.125_{10} = -111100.001_2 \\
\qquad\qquad\qquad\qquad\quad= (-1)^1 × 2^{-5} × 1.11100001
$$



##### 浮点数剖析

Java中有两种浮点数值表示方式：**Float**：单精确度（32位）、**Double**：双精确度（64位）

一个 浮点数 其实可以分成三部分：

**Value**(数值) = **sign**(数符) × **exponent**(指数) × **fraction**(分数)

具体运算形式为：
$$
V = (-1)^S × 2^{E - (2^{e-1}-1)} × (1+M)
$$
其中： 

- S：**符号位(sign bit)的数值**，可确定该公式正负。
- E：**指数偏移值(exponent bias)的数值**。等于指数的实际值加上**固定偏移值**
- e：**存储指数的位元的长度**。单精度和双精度是不同的。
- M：**有效数(significant)。**由于这种表示下的尾数有一位隐含的二进制有效数字，为了与二进制科学计数法的 尾数（mantissa）相区别，IEEE754称之为 有效数(significant)

##### 整体呈现

从上所属，二进制浮点数是以**符号数值表示法**的格式存储，它分为三个域：

![IEEE 754浮点数的三个域](https://img.cialle.com/202206101751164.png)





##### **sign**(数符)

$$
sign: (-1)^S\\
\\
即 S=0时 表示数值为正数\\
S=1 时 表示数值为 负数
$$

详细介绍：整个二进制浮点数 **最高位有效位** 被指定为 **符号位（sign bit）** 

同整型数值一样，符号位（sign bit）通过上述运算形式可确定该式正负性。

<font color=red>Sign域 存储的就是 S----符号位(sign bit) </font>





##### **exponent**(指数)

$$
exponent:2^{E - (2^{e-1}-1)}\\
E = 指数偏移值(exponent\ bias)的数值\\
e = 存储指数的位元的长度
$$

指数偏移值，即 浮点数表示法 中指数域的编码值，它等于 指数实际值加上某个固定的指，IEEE 754标准规定该固定值为2<sup>e-1</sup>-1，其中的e为存储指数的位元的长度。

采用这种方式表示的目的是简化比较。因为，指数的值可能为正也可能为负，如果采用[补码](#补码)表示的话，全体符号位S和Exp自身的符号位将导致不能简单的进行大小比较。正因为如此，指数部分通常采用一个无符号的正数值存储。单精度的指数部分是−126～+127加上偏移值127，指数值的大小从1～254（0和255是特殊值）。浮点小数计算时，指数值减去偏正值将是实际的指数大小。

<font color=red>Exponent域 存储的就是 E----指数偏移值(exponent bias)</font>

##### **fraction(分数)**

$$
fraction:(1+M)\\
M=有效数(significant)
$$

通常情况下，分数(fraction)部分最高有效位(即整数部分)为1。

所以有效数(significant)则省去整数部分，将整数部分直接存储在内存当中。

<font color=red>Fraction域 存储的就是 M----有效数(significant)</font>



##### 单精度与双精度的区别

![image-20220611012530009](https://img.cialle.com/202206110125186.png)

#### 举例部分

> 不知道你上述理论是否看懂了呢
>
> 反正我写的时候是稀里糊涂的 笑死
>
> 但是总结一下 记住这三个点即可
>
> **Sign域** 存储的就是 **S**----**符号位0正1负** 
>
> **Exponent域** 存储的就是 **E**----**实际指数+固定偏移量**
>
> **Fraction域** 存储的就是 **M**----**去掉"1."的尾数**

下方举例部分均以float单精度展示，双精度同理。

##### 简单版

假设 我们需要将 -6.25 设置为32位单精度类型，下面是计算机将会发生的事。

1. 第一步：
   确定数字的符号
   因为-6.25是负数，所以 **Sign域** 内容为 <font color=yellow>1 </font>
2. 第二步：
   我们需要以2为底的科学计数法 来表示6.25,这意味着我们需要将它 分解成 (1 <= x < 2)范围内的数字 × 2的n次幂
   　　　　　6.25 = (1 + Fraction) × 2<sup>n</sup>
   　　　　　它等同于
   　　　　　6.25 / 2<sup>n</sup> = 1 + Fraction
   因此，我们将6.25 除以 2的n次幂 就可以得到 (1 + Fraction) 
   　　　　　6.25 / 2<sup>1</sup> = 3.125
   　　　　　6.25 / 2<sup>2</sup> = 1.5625
   故此，得到：6.25 = (1 + 0.5625) × 2<sup>2</sup>
3. 第三步：
   现在，我们发现指数上面使用的2的n次幂 n=2 ，32位单精度类型的固定偏移量为127。
   因此： **Exponent域** 内容为 2 + 127 = 129 = <font color=gree>1000 0001 </font>
4. 第四步：
   我们以二进制编写Fraction，连续 × 2。直至小数部分为0 或 重复出现 或 超出23位（单精度的 Fraction域 位元长度）
   　　　　　0.5625 × 2 = <font color=red>1</font>.125
   　　　　　0.125  × 2 = <font color=red>0</font>.25
   　　　　　0.25   × 2 = <font color=red>0</font>.5
   　　　　　0.5    × 2 = <font color=red>1</font>.0
   由此，我们得到了<font color=red>1001 0000 0000 0000 0000 000</font> (补零直至单精度Fraction域位元长度)
5. 第五步：
   完成，我们将整体结果按照正确的顺序拼接起来
   　　　　　32位单精度 我们使用 1位作为sign 8位作为Exponent 23位作为Fraction
   因此，IEEE 754 格式的 -6.25是：
   <font color=yellow>1 </font> <font color=gree>1000 0001 </font> <font color=red>1001 0000 0000 0000 0000 000</font> 

##### 进阶版

看起来很简单对不对，接下来我们讨论，为什么不精准呢？

继续举例 假设 我们需要将 0.3 设置为32位单精度类型，下面是计算机将会发生的事。

1. 第一步：
   因为0.3是正数，**Sign域** ：<font color=yellow>0 </font>
2. 第二步：
   以2为底的科学计数法 来表示0.3：
   　　　　　0.3 / 2<sup>-1</sup> = 0.6
   　　　　　0.3 / 2<sup>-2</sup> = 1.2
   得到：0.3 = (1 + 0.2) × 2<sup>-2</sup>
3. 第三步：
   指数为：2<sup>-2</sup> 则**Exponent域** 内容为 -2 + 127 = 125 = <font color=gree>0111 1101</font>
4. 第四步：
   我们以二进制编写Fraction：
   　　　　　0.2 × 2 = <font color=red>0</font>.4
   　　　　　0.4 × 2 = <font color=red>0</font>.8
   　　　　　0.8 × 2 = <font color=red>1</font>.6
   　　　　　0.6 × 2 = <font color=red>1</font>.2
   　　　　　0.2 × 2 = <font color=red>0</font>.4
   　　　　　0.4 × 2 = ...
   如你所见，重复了，循环了。
   但是，单精度格式仅为我们提供了23位来表示我们的Fraction部分。
   我们不得不采用近似值，将第24位数字0舍1入到第23位数字
   由此，我们得到了<font color=red>0011 0011 0011 0011 0011 010</font> (将第24位数字0舍1入到第23位数字)
5. 第五步：
   完成，我们将整体结果按照正确的顺序拼接起来
   　　　　　32位单精度 我们使用 1位作为sign 8位作为Exponent 23位作为Fraction
   因此，IEEE 754 格式的 -6.25是：
   <font color=yellow>0</font>  <font color=gree>0111 1101</font>  <font color=red>0011 0011 0011 0011 0011 010</font>

**也正是因为这个“将第24位数字0舍1入到第23位数字“，就导致了浮点数在底层存储中就是不精准的。**



---

# 最后

thanks:

[Java 基本数据类型_w3cschool](https://www.w3cschool.cn/java/java-basic-datatypes.html)

[IEEE 754 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.m.wikipedia.org/zh-my/IEEE_754)

[IEEE-754 浮点转换器 (h-schmidt.net)](https://h-schmidt.net/FloatConverter/IEEE754.html)

[The IEEE 754 Format (emory.edu)](http://mathcenter.oxford.emory.edu/site/cs170/ieee754/)

以及很多参考完以后关闭的网站，忘记做记录，IEEE754查了很久的相关资料，自己翻译了一会，实在是太乱了。网上也没有什么统一的称呼，最后实例部分英文这边的话凑合看吧。实在不知道咋翻译了，涉及相关词汇太多。网站的话也不太想做评论区，有需要的话可以邮箱cialle@126.com。最后转载请注明出处，谢谢。



此篇文章写了蛮长时间，以此记录 “面试官问到我 为什么float是不精准 我没答清晰 被冷嘲热讽，” 这件事
